Over the last couple of weeks, we have discussed how to use files, but what is the purpose of these files? What files can Python open? What files can Python create? Why do we need files? The answer deals specifically with how memory works. When you write a script, you create several variables that store data. However, these variables have a lifetime of your script which means you lose all that data unless you store it. Sometimes a simple `print` statement is sufficient but sometimes you need to store the data for later use. Let’s demonstrate this idea through an example. You’re writing a paper for a history class on MS Word or your word processor of choice. You have two options: 1) write as much data as possible then print out a copy risking having to type the document over again to fix a typo or 2) write as much data as possible then save it to a file so you can edit it later quickly. Most of you are probably saying, “No duh! You totally use #2.” Well, the same concept applies to Python (and all other programming languages). Why run a bunch of code again to produce the same results then process said results? There are hundreds of different file formats so it’s not beneficial for us to discuss all of them here. I’m going to introduce you to random access file formats and comma separated value (CSV) files today. These should give you a foundation in file formats which will allow you to read the documentation of files you’re truly interested in using.

**Random Access File**
If you have ever used a SQL style database before, this section might sound familiar to you. A random access file is a file that is built specifically for finding data quickly. This type of file is used as a database which is similar to, but not exactly like, a MS Excel spreadsheet. Let’s say you have a set of objects you want to store for later use. For demonstration, we’re going to describe a simple `Person` object that has three fields: `name`, `age`, and `gender`. We’re going to assume a `Person`’s name is less than 20 characters (20 bytes or 80 bits). Their age will be represented as an integer (32 bits or 4 bytes), and their gender will be a boolean (1 bit) where `false` is female and `true` is male. Each of `Person` entry is going to be a set size (113 bits => 28.25 bytes). Each `Person` is also going to receive an `id` which represents their line number in the file. So, we can `write` a `Person` to the file and use `seek` to jump to their entry and then use `read` to read in the object’s values and assign them to a new object. See [this week’s gist][1] for an example of this. Now, you’re going to have to do a lot of error handle and data tracking so this isn’t the most efficient file of all time, but it’s optimized for the best searching results because each entry is of an identical size. Nifty right?

**Comma Separated Value (CSV)**
Similarly to random access files, CSVs contain one entry on a line, but each entry is separated by a comma. These files are a little easier to read in because of Python’s `split` method for strings. Note, I said “strings”. This is due to the fact that we need to be consistent and only `read` and `write` ASCII or unicode characters to and from files. Again, see [this week’s gist][1] for an example of using CSVs. CSVs are optimized for space because they use the minimal space possible (no place holders) but are slow to search because each entry is of a different size.

As you can see, we need to know the file type we are dealing with so we can properly handle the data and import it into our programs accordingly. If there is a specific file format you would like to discuss, feel free to start a discussion below. Other than that, have a good week and see you next time! :)

  [1]: https://gist.github.com/sharocko/5615696
